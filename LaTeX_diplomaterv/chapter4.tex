%----------------------------------------------------------------------------
\chapter{Az elvégzett munka}
%----------------------------------------------------------------------------

(40 oldal)

%----------------------------------------------------------------------------
\section{Rendszerterv}
%----------------------------------------------------------------------------
\begin{figure}[!ht]
\centering
\includegraphics[width=100mm,keepaspectratio]{figures/Rendszerterv.png}\\
\end{figure}

\subsection{Kollaboráció}

Mivel kollaboratív alkalmazásról van szó elsőbbségi szempont az ellentmondó, nagyjából egyidejű változtatások konfliktusait feloldani. Felmerült ötletként a Google Docs-ban alkalmazott Operational Transformation megoldás amiben folyó szöveg egyidejű módosítása van megoldva ``előbb-útóbbi'' konzisztencia elérésével. Az Operational Transformation algoritmust nehéz implementálni CITATIONNEEDED, viszont vannak nyílt forráskódú megoldások rá\footnote{http://www.sharejs.com}. Nem ezen a vonalon indultam el, mert nehézkesnek gondoltam annak a rétegnek a fejlesztését ami a DOM-ban levő gráfot szöveggé- és vissza transzformálja akkor is , ha meg van oldva a különböző kliensek által látott szövegreprezentáció kollaboratív változtatása. 

Erre az alternatíva ami végül kiválasztásra került egy meglehetősen pehelysúlyú megoldás: a gráf módosítását jól meghatározott eseményekként defineálom és ezek az események a többi felhasználóhoz Websockets broadcast üzeneteken keresztül jutnának el. Egy példa esemény egy entitás módosítása: az A kliens böngészőjében elhúzunk egy dobozt, a kliensoldali kód a szervernek egy kérésben szól a módosításról, a szerver perzisztálja az adatot és Websockets broadcast üzeneten keresztül értesíti a többi résztvevőt. Ilyenkor az esemény üzenet az új értékét is tartalmazza az entitásnak ami módosult. 

Ebben a megoldásban igazából semmi konfliktus feloldás nincsen és a továbbiakban be fogom mutatni, hogy ez nem is feltétlenül szükséges. Először is nézzük meg, hogy milyen jellegű konfliktusokról lehet szó; a közösen manipulált elemeket lehet egyidejűleg létrehozni, törölni és módosítani, feltételezve két szereplőt a következő esetek relevánsak:

\begin{enumerate}
\item { törlés - törlés} Ha majdnem egyszerre ketten törlik ugyanazt az entitást, akkor csak kezelni kell kliens és szerver oldalon, hogy a később érkező törlés művelet már fölösleges. 
\item { módosítás - módosítás} Itt két eset lehetséges:
\begin{enumerate}
\item Különböző attribútumok változnak. Ekkor, ha csak a változásokat küldjük el , akkor ????összefésülhetők az attribútumok, ha nem , akkor igazából a következő esetről beszélünk,
\item Ugyanazok az attribútumok változnak. Ekkor sajnos arról beszélünk, hogy egyidejűleg az első felhasználó jobbra 
húzta , a másik felhasználó balra húzta az objektumot és a később történt esemény fog végül érvényesülni. 

Az első kérdés ami felmerül itt az, hogy ez egyáltalán próbléma? Próbléma, mert a mozgatás elvesztése apró művelet könnyen megismételhető, de ha egy hosszú szöveg beírásáról van szó egy attribútum mezőbe, akkor nem kívánatos elveszíteni azt. Egyszerű modellek szerkesztésénél mint egy állapot diagram nem tipikus a hosszú szövegek beírása. 

Jó esetben körülbelül 100 ms alatt mindenkihez eljutnak az események, ez azt jelentené, hogy nem lehet annyira gyakori ez a próbléma, hogy egy verziókezelő rendszerhez hasonló megoldással lassítsuk a felhasználók munkafolyamatát.

\pdfcomment[icon=Note]{insert: Zárolás}

Egy egyszerű felhasználói élmény javítás egy jelzés lesz, ami úgy néz ki, hogy minden felhasználó látja, hogy ki éppen milyen objektumot jelölt ki színekkel jelölve. Ha valaki más ki szeretné törölni az objektumot aminek az életrajzát éppen írjuk, akkor a rendszer legalább szól, hogy azt valaki kijelölte. Ez a megoldás egyik fő előnye, hogy nem bonyolítja egyáltalán a munkafolyamatot példáúl a zároláshoz képest.

\end{enumerate}
\item { módosítás - törlés } Ez a szituáció ugyanaz mint az előző. A fent említett megjelölés egy megoldás, de egy visszavonás művelet megnövekedett komplexitás árán megoldaná teljesen a próblémát.
\end{enumerate}

A létrehozás-törlés, létrehozás-módosítás és létrehozás-létrehozás kombinációk nem fordulhatnak elő ugyanazon az entitáson, hiszen nem lehet olyat módosítani egyidőben amit a másik kliens hoz létre ugyanabban az időben.

Ha a két művelet két különböző csúcsot érint, akkor nincs próbléma, mert triviálisan mindkét művelet érvényesül, ha a egy csúcsot és egy hozzá tartozó élet érint, akkor sincs gond, mert a csúcs törlése maga után vonja az él törlését is. 

Az 5FEJEZET-ben teljesítményelemzés keretein belül további indoklást részletezek. 

Az előnye a megoldásnak az egyszerűség és a remélhetőleg jobb felhasználói élmény ami abból eredhet, hogy visszaigazolás nélkül módosul a felhasználó felületén a diagram a saját beavatkozása után. Egy olyan alkalmazásnál ami egy nem-kollaboratív offline alkalmazással versenyzik létfontosságú a kis reakcióidő a felületen. Az egyszerűség maga után vonja a könnyebb karbantarthatóságot és kisebb hibalehetőséget.   


Egy hátránya az, hogy az események száma nő a komplexitás növekedésével. 



\subsubsection{Eltérések detektálása}

Egy funkció ami jelzi, hogy két felhasználó eltérő diagramot lát holott ugyanazt kellene, hogy lássák -- nevezzük eltérés detektálásnak -- két szempontból is hasznos lesz: egyrészt a teljesítményelemzés során fel lehet használni arra, hogy a kollaborációs megoldás hatékonyságát vizsgáljam különböző paraméterek mellett , másrészt felhasználói élmény szempontjából szükséges, hiszen, ha eltérést vesz észre az algoritmus, akkor a diagram újratöltésével orvosolható a próbléma. 
A kérdés az, hogy mi az amit összehasonlítunk ilyenkor? A teljesítményt és a sávszélességet szem előtt tartva egy egyszerű megoldás egy hash értéket számolni a diagramból majd ezt összevetni a többi kliens által kiszámolt értékkel.

Ux

Szerver is részt vesz?

Teljesítmény

Nyugtázás?

Másik kérdés, hogy, hogyan oldható meg az, hogy ugyanabban az időben normális körülmények között előfordulhat, hogy 



%----------------------------------------------------------------------------
\section{Adatbázis}
%----------------------------------------------------------------------------

A kliens oldalról nézve egy felhasználói diagram fő elemei az entitások és a köztük lévő kapcsolatok (vagy csúcsok és élek a gráfban). 


\begin{lstlisting}
{
    "_id" : ObjectId("52486e8e9b7f14a725000001"),
    "position" : {
        "top" : 312.9618225097656,
        "left" : 607.920166015625
    },
    "title" : "Alszik",
    "document" : "5242aa48ddda9b0000000001"
}
\end{lstlisting}

Az entities kollekcióban tárolva vannak a diagram entitásai. Lehetne egy kollekcióban tárolni mindent ami egy diagramhoz tartozik, de azért van szükség külön kollekcióban tárolni az entitásokat, mert az egyedi azonosítójukra szükség van a kliens oldalon is. ERROLBOVEBBENAKLIENSOLDALIALKALMAZASBAN
A position attribútum konkrétan a kliensoldali CSS pozícionálásra van használva, a document attribútum egy idegen kulcs lenne, ha relációs adatbázisról beszélnénk, de valóban annak a dokumentumnak az azonosítóját tárolja aminek része.

\begin{lstlisting}
{
    "_id": "524b08b1b7f4db8e68000001",
    "connections": [
    {
        "from": "524b08b4b7f4db8e68000002",
        "to": "524b08bdb7f4db8e68000003",
        "label": "valami"
    },
    ...],
    "entities": [],
},
\end{lstlisting}


%----------------------------------------------------------------------------
\section{A szerver oldali alkalmazás}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{API}
%----------------------------------------------------------------------------

Az AngularJS kliens egy API-n keresztül kommunikál a szerverrel a dinamikus tartalom lekérdezése és mentése céljából. Ez az API JSON adatokat szolgáltat, amit akár módosítás nélkül fel lehet használni a kliens oldalon bemásolva egy AngularJS model-be; ugyanígy az API-nak beküldött új JSON objektumok módosítás nélkül a MongoDB adatbázisba íródnak. Az API több csomagoló függvényből áll, minden entitás típusra egy; egy ilyen csomagolófüggvényben a létrehozás, törlés, módosítás és olvasáshoz implementáltam függvényeket és ezeket a konkrét API-kat require segítségével betöltöm a \lstinline{routes} modul \lstinline{index.js} fájlba, ahol példányosítom. Két függősége is van egy ilyen API modulnak: az adatbázis kapcsolat és a socket szerver példány.

\begin{lstlisting}
    var DocumentApi = require('./api/docs.js');
    module.exports = exports = function(app, db) {
        sa = new SocketAdapter(app);
        api = new DocumentApi(db, sa);
        app.get('/api/docs', api.docs);
        app.get('/api/docs/:id', api.doc);
        app.post('/api/docs', api.adddoc);
        app.put('/api/docs/:id', api.updatedoc);
        app.delete('/api/docs/:id', api.deletedoc);
    ...
    }
\caption{API összekapcsolása a szerverrel}
\end{lstlisting}

\begin{lstlisting}
module.exports = function (db, sa) {
  var docs = db.collection("docs");

  this.deletedoc = function(req, res) {
    var oid = mongo.BSONPure.ObjectID(req.params.id)
    docs.remove({_id: oid}, function(err, removed){
      res.json(removed);
    })  
  ...
\caption{A DocumentApi törlés függvénye}
\end{lstlisting}

Amikor id-ra hivatkozunk mindig szükséges egy \lstinline{BSONPure.ObjectID} példányba csomagolni az azonosítót, mert csak úgy lehet felhasználni MongoDB lekérdezésben.

%----------------------------------------------------------------------------
\subsection{Kétirányú kommunikáció}
%----------------------------------------------------------------------------

Ha azt nézzük, hogy egyidejűleg x darab diagramot szerkeszt diagramonként y darab különböző felhasználó, akkor felmerül az a próbléma, hogy hogyan követjük nyomon, hogy milyen eseményeket milyen socket-ekre kell továbbítani, más szóval hogyan történjen a broadcast. Szerencsére a Socket.IO könyvtár ezt megoldja úgynevezett szoba funkcionalitással, egy szobához hozzáadott socketek tudnak broadcast üzenetet küldeni a többi szobabeli socketnek, ráadásul a socketek eltávolítása is átlátszóan történik és nem kell memóriakezelési próblémákkal küzdeni.Így a socket kezelő szerver oldali logika meglehetősen vékony lesz, de ez is a célja a Socket.IO könyvtárnak. 

Mivel minden szerkesztendő diagramhoz tartozik egy szoba, kézenfekvő a diagram azonosítóját beállítani a szoba neveként. A modularitást szem előtt tartva, a socket kezeléssel kapcsolatos funkcionalitást egy SocketAdapter nevű objektumba csomagoltam. A SocketAdapter példány példányosítja a Socket.IO szervert és gondoskodik az új kapcsolatok beállításáról, rajta keresztül lehet hívni Socket.IO függvényeket.

Egy új socket-re eseménykezelőket hoz létre a SocketAdapter és a legfontosabb talán a \lstinline{room:change} esemény, ami egy diagram megnyitásakor, vagy másik diagram-ra való áttéréskor hívódik meg a kliens által. Ekkor a régi szobából átkerül az új szobába a socket. 

\begin{figure}[!ht]
\centering
\includegraphics[width=15cm,keepaspectratio]{figures/collaboration-seq.png}
\caption{Entitás módosítás feldolgozása}
\label{fig:angularhtml}
\end{figure}




%----------------------------------------------------------------------------
\section{A kliens oldali alkalmazás}
%----------------------------------------------------------------------------



Az AngularJS alkalmazásomnak a fő építőelemei a szolgáltatások, direktívák és kontrollerek. A kontrollerek a DOM egy részéért felelnek összekapcsolva a modellt és a view-t; a direktívák a HTML kiterjesztését valósítják meg új elemekkel, amik újrafelhasználható UI komponenseket hoznak létre; a szolgáltatások ugyancsak újrafelhasználható függőségek, amiket tetszőleges más komponensbe lehet injektálni.

A külső függőségei: 
\begin{enumerate}
\item az AngularJS könyvtár, 
\item az underscoreJS könyvtár ami funkcionális programozási elemekkel bővíti a nyelvet,
\item egy md5 hash-t számoló függvény,
\item Jquery UI a DOM elemek mozgatása miatt,
\item PlumbJS ami DOM elemeket köt össze nyilakkal.
\end{enumerate}

Az első próbálkozásaimban nyilakat a HTML SVG path segítségével próbáltam megvalósítani úgy, hogy adatkötés segítségével frissült a nyíl pozíciója egy elhúzott DOM elemhez képest. Sok funkcionalitást kellett volna implementálnom, így kerestem alternatívákat. A PlumbJS egy élhúzó modul aminek segítségével DOM elemeket meg lehet jelölni mint él kiindulópont vagy végpont és ezt a kettőt összeköti egy SVG alapú vektoros nyíllal. Gondoskodik az új él behúzásáért, nyilvántartja a létrehozott éleket, DOM elem körül egy kerületet kell defineálni és ahhoz kapcsolja az élek végpontjait. Továbbá tud nyilat húzni és cimkét tenni a vonalra; azt a következtetést vontam le, hogy mindent tud, amire szükségem van.  

\subsubsection{Jade markup}

A Jade egy olyan markup nyelv ami HTML-t helyettesít, az a fő különbség, hogy a fa nem XML alapú, hanem a gyerekek indentációval különülnek el a szülőtől, ez amúgy is általánosságban szokás, viszont így nincs rá szükség, hogy be is zárjunk HTML elemeket. Az eredmény karakterszámon spórol és olvashatóbb markupot eredményez. A Jade template a Node alkalmazásban fordul le HTML tartalommá. A Jade valóban template rendszer is, tartalmaz példáúl elégazásokat, de én csak markupként használtam, a logika az az Angular kontrollerekre van bízva.

Template öröklés úgy működik, hogy az \lstinline{extends} paranccsal megjelöljük, hogy ki melyik template a szülő template. A szülőben \lstinline{block} elemeket hozhatunk létre és az ezekben levő DOM rész felülírható a gyerek template-ben. 

Egy hasznos funkció benne a kikommentezés, ami úgy használandó mint a Javascript egy soros komment, viszont a szülő kikommentezése a gyerekek kikommentezését is maga után vonja, így se két helyen nem kell kommentezési parancsot tenni a markupba (a HTML esetében nyitó és záró komment tag kellett) se kiválasztani nem kell a kommentezendő DOM részt.

\begin{lstlisting}
table
  tr
    td(style='width: '+(100/2)+'%').
      Twitter
    td Facebook
\caption{Példa Jade markup}
\end{lstlisting}

\begin{lstlisting}
<table>
  <tr>
    <td style="width: 50%">Twitter</td>
    <td>Facebook</td>
  </tr>
</table>
\caption{Az ekvivalens HTML}
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{Direktívák}
%----------------------------------------------------------------------------

\subsubsection{ntDraggable}

Az ntDraggable direktíva a mozgatható diagram dobozokat valósítja és a \lstinline|<div ng-repeat="entity in shared_document.entities" nt-draggable="nt-draggable" class="drag"></div>| kód szúrja be őket a DOM-ba. Az adatkötésnek köszönhetően, ha az entities tömb bővül, vagy ritkul, vagy egy eleme megváltozik, akkor ez a DOM-ban is érvényesül. Ez a direktíva egy HTML template-t is meghatároz a mozgatható entitásnak, gyakorlatilag olyan mintha az eredeti DOM-ban lenne ez a HTML, de, ha új helyre szeretnénk másolni a funkcionalitást nem kell lemásolni. A template a következőket tartalmazza:

\pdfcomment[icon=Note]{insert: Kep a direktivarol}

\pdfcomment[icon=Note]{insert: Kep a függőségi gráfról}

\begin{enumerate}
\item Egy gyerek div ami a \lstinline|{{entity.title}}| kötésen keresztül a doboz nevét írja ki,
\item A model megváltozása esetében a pozíciót is tudom frissíteni CSS attribútumra való kötéssel: \lstinline| style='top:{{entity.position.top}}px;left:{{entity.position.left}}px'|
\item Egy entitás kiválasztása esetében egy CSS osztályt kell hozzáadni a szülőhöz, jelezva , hogy ki van választva. Az AngularJS szolgáltat erre egy \lstinline{ng-class} direktívát ami feltételes CSS class beállítást valósít meg. 
\item \lstinline|id={{entity._id}}| Az entitás adabázis azonosítója egy az egyben a DOM id lesz -- egy nagyon kézenfekvő megoldás.
\item A többi felhasználó kijelölését egy kis doboz jelöli, ami a felhasználóhoz rendelt színnel lesz kiszínezve.
\end{enumerate}

Az ntDraggable direktíva egy \lstinline{link} függvényt is meghatároz, ennek a törzse pont az a hely ahova a DOM manipuláció és eseménykezelő logikát akarjuk tenni -- pontosabban itt az egérrel való tologatást állítom be. Itt látszik, hogy ez a DOM manipuláció függetlenítve van a prezentációs rétegtől és az alkalmazás többi részétől, ami tesztelhetőség és újrafelhasználás szempontjából értelmes. 

Ahhoz, hogy a div mozgatása a jsPlumb élek mozgatását vonja maga után nem \lstinline{jQuery.draggable}-t kell használni, hanem \lstinline{jsPlumb.draggable}-t, ami kiterjeszti az előbbit. A DOM irányából a kötés a modelhez csak a \lstinline{stop} draggable eseményre történik, mert nem akarunk minden egérmozgatásról értesíteni a többi felhasználót, az nem csak hogy pazarló lenne, hanem zavaró is, így csak akkor terjed a módosítás , ha új helyre engedjük el a dobozt.

Az élhúzás egyszerűség kedvéért ugyancsak egér kattintás és húzogatással történik, de nem a dobozt húzzuk, hanem a nevét, ekkor a jsPlumb gondoskodik az új ideiglenes lógó él kirajzolásáról. Ehhez jsPlumb \lstinline{makeSource} és \lstinline{makeTarget} parancsokat kell hívni, ezek beállítják a cím dobozokat mint cél és forrás a jsPlumb élekhez.

Megjegyzendő, hogy direktívák használata miatt a kontroller és a DOM template nincs csatolva a jsPlumb modulhoz, tehát, ha lecserélnénk a jsPlumb megoldást egy sajátra, ez remélhetőleg csak a direktíva módosítását vonja maga után.

\subsubsection{saveSelected}

A szerkesztő kontrollere nyilvántartja a kiválasztott entitást a gráfban, egy korábbi verzióban kettőt is lehetett kiválasztani, majd ezeket össze lehetett gombnyomással kapcsolni éllel, de ez helyettesítve lett a fennebb említett felhasználói szempontból egyszerűbb megoldással. 

Kijelöléskor  
\pdfcomment[icon=Note]{insert: Kep az attributes pane-rol}
az entitás attribútumai megjelennek a részlet nézeten és itt lehet módosítani példáúl a címét. Az adatkötés elintézi, hogy az input doboz tartalma megegyezzen mindkét irányba a modellel, de ettől még nem fognak propagálódni a módosítások a szerverre. 

Ez a direktíva azt csinálja meg, hogy amilyen input elemhez csatoljuk, annak a fókusz elvesztése a kijelölt elem szerverre való mentését váltja ki. A \lstinline{saveSelectedCon} direktíva hasonlóan élek szerverre mentését váltja ki.


\subsubsection{ntDelete}

Az ndDelete direktíva a billentyű funkciókért felelős, amiből kettő van: entitás létrehozás (E gomb) és törlés (backspace gomb). A triviális megoldás az, hogy a document elemre egy \lstinline{keydown} eseménykezelőt állítunk be. Ez sajnos nem elég, mert, ha éppen szöveget szerkesztünk az oldalon, akkor arra is reagálni fog. A direktíva eseménykezelője megkülönbözteti, hogy az eseményt fogadó elem input vagy textarea elem-e és ha igen, akkor az alapértelmezett működés következik be, egyébként meg a backspace hatására az éppen kijelölt entitást vagy élt kitörli.

Fontos megjegyezni, hogy az olyan callback, ami nem AngularJS része, példáúl egy jQuery eseménykezelő, nem fogja az adatkötés frissítését kiváltani, tehát ha backspace gombnál kitörlünk egy entitást a model lsitából, ez a DOM-ban nem fog érvényesülni, ilyenkor \lstinline{$scope.$apply();} parancsot kell hívni. 

%----------------------------------------------------------------------------
\subsection{Szolgáltatások}
%----------------------------------------------------------------------------

\subsubsection{SocketService}

A websocket kezelés egy tökéletes példa saját AngularJS szolgáltatásra, ezt akár több kontroller, direktíva vagy szolgáltatásba szeretnénk injektálni és fontos lenne a könnyű hozzáférés és a scope frissítés \lstinline{$scope.$apply();} segítségével. Pontosan ez történik, a SocketService kapcsolódik a szerveroldali Socket.IO szerverhez, majd apply blokkban futtatja a socket üzenet küldés (emit) és fogadás (on) callback metódusokat.

Így kontrollerből átlátszóan használom ezt az adapter és ez a következőképpen néz ki kontrolleren belül:

\begin{lstlisting}
 function EditorCtrl($scope,socket, ...) {
    socket.on('entity:create', function (data) {
      var entities = $scope.shared_document.entities;
      entities.push(data.obj);
    });
 }
\end{lstlisting}

\subsubsection{API szolgáltatások}

AngularJS az alacsonyszintű $http szolgáltatást kínálja egyszerű AJAX hívásokra, de, ha egy API-val dolgozunk, akkor a $resource egy olyan absztraktabb szolgáltatás ami REST-szerű API-khoz való kapcsolódást valósít meg. Ekkor saját szolgáltatást kell defineálni egy endpoint megadásával és a műveletek meghatározásával:

\begin{lstlisting}
  app.factory('DocumentService', ['$resource', function($resource){
  return $resource('/api/docs/:id', {id:'@_id'}, 
    { update: {method:'PUT' } , 
      query: {method:'GET', isArray: true}});
    }]);
\end{lstlisting}

Látható, hogy a saját DocumentService API-nek a $resource a függősége, az /api/docs/:id URL-hez kapcsolódik és kibővítettem két metódussal ami az update és a query metódus. 

Új entitás létrehozásakor kevés kódot kell futtatni:
\begin{lstlisting}
 $scope.addEntity = function() {
    EntityService.save({ 
      position: {"left":300, "top":300 },
      title:"*", 
      document: $scope.shared_document._id}, 
      function(res){}
    )
  }
\end{lstlisting}

Az a kényelmes mellékhatása van ennek a kódnak, hogy új entitás létrehozásakor a DOM-ba kerül.\pdfcomment[icon=Note]{insert: Egybol belekerul a domba?}

\subsubsection{JSPlumbService}

A laza csatolás szem előtt tartása miatt a jsPlumb hívások is egy szolgáltatásban vannak és nincsenek a kontroller vagy view-hoz szorosan csatolva. 

Ez a szolgáltatás beállítja az alapértelmezett jsPlumb paramétereket:

\begin{enumerate}
\item az élek görbülésének mértéke és stílusa,
\item az élek színe, vastagsága,
\item a végpontok stílusa,
\item egy overlay beállítása, ami nyilat valósít meg,
\item  rögzítési pont -- ez esetben folytonos -- ami azt jelenti, hogy nem diszkrét számú pontra illeszkedhet, hanem a doboz kerülete mentén egy közelebbi ponthoz fog kapcsolódni a másik doboz helyzetéhez képest.
\end{enumerate}

Két metódust szolgáltat : új élek létrehozása és egy új diagram betöltésekor  vagy váltáskor az élek felrajzolása egy éllista alapján.
Nincsen adatkötés az élek és az AngularJS modellek között, ezért itt kell ezt megvalósítani.


\subsection{A szerkesztő kontroller}

\begin{enumerate}
\item A kontroller betöltésekor lekéri a DocumentService-től az összes diagramot és majd az elsőt betölti,
\item defineál egy inicializáló metódust ami a diagram betöltését valósítja meg. Ekkor bizonyos változók újra az eredeti értéküket kapják meg, majd frissülnek az API-ból a diagram adatai, az entitásokat lekéri és inicializálja az éleket. A végén socket üzenetet küld arról, hogy az új diagramra váltott és a szerveroldlon egy másik socket szobába kerül;
\item új diagram létreho
\item 
\item 
\end{enumerate}


%----------------------------------------------------------------------------
\subsection{Unit teszt esetek}
%----------------------------------------------------------------------------


\input{src/mark}


\input{src/compile}




%----------------------------------------------------------------------------
\section{A Websockets protokoll vizsgálata}
%----------------------------------------------------------------------------

A Wireshark csomagvizsgáló eszközzel megvizsgáltam jobban a websockets kommunikációt.  




%----------------------------------------------------------------------------
\section{Promises és a ``callback hell''}
%----------------------------------------------------------------------------
Derp.


