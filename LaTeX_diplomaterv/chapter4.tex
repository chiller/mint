%----------------------------------------------------------------------------
\chapter{Az elvégzett munka}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\section{Rendszerterv}
%----------------------------------------------------------------------------
\begin{figure}[!ht]
\centering
\includegraphics[width=100mm,keepaspectratio]{figures/Rendszerterv.png}\\
\end{figure}

\input{src/collaboration}

%----------------------------------------------------------------------------
\section{Adatbázis}
%----------------------------------------------------------------------------

A kliens oldalról nézve egy felhasználói diagram fő elemei az entitások és a köztük lévő kapcsolatok (vagy csúcsok és élek a gráfban). 


\begin{lstlisting}
{
    "_id" : ObjectId("52486e8e9b7f14a725000001"),
    "position" : {
        "top" : 312.9618225097656,
        "left" : 607.920166015625
    },
    "title" : "Alszik",
    "document" : "5242aa48ddda9b0000000001"
}
\end{lstlisting}

Az entities kollekcióban tárolva vannak a diagram entitásai. Lehetne egy kollekcióban tárolni mindent ami egy diagramhoz tartozik, de azért van szükség külön kollekcióban tárolni az entitásokat, mert az egyedi azonosítójukra szükség van a kliens oldalon is. ERROLBOVEBBENAKLIENSOLDALIALKALMAZASBAN
A position attribútum konkrétan a kliensoldali CSS pozícionálásra van használva, a document attribútum egy idegen kulcs lenne, ha relációs adatbázisról beszélnénk, de valóban annak a dokumentumnak az azonosítóját tárolja aminek része.

\begin{lstlisting}
{
    "_id": "524b08b1b7f4db8e68000001",
    "connections": [
    {
        "from": "524b08b4b7f4db8e68000002",
        "to": "524b08bdb7f4db8e68000003",
        "label": "valami"
    },
    ...],
    "entities": [],
}a,
\end{lstlisting}


%----------------------------------------------------------------------------
\section{A szerver oldali alkalmazás}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{API}
%----------------------------------------------------------------------------

Az AngularJS kliens egy API-n keresztül kommunikál a szerverrel a dinamikus tartalom lekérdezése és mentése céljából. Ez az API JSON adatokat szolgáltat, amit akár módosítás nélkül fel lehet használni a kliens oldalon bemásolva egy AngularJS model-be; ugyanígy az API-nak beküldött új JSON objektumok módosítás nélkül a MongoDB adatbázisba íródnak. Az API több csomagoló függvényből áll, minden entitás típusra egy; egy ilyen csomagolófüggvényben a létrehozás, törlés, módosítás és olvasáshoz implementáltam függvényeket és ezeket a konkrét API-kat require segítségével betöltöm a \lstinline{routes} modul \lstinline{index.js} fájlba, ahol példányosítom. Két függősége is van egy ilyen API modulnak: az adatbázis kapcsolat és a socket szerver példány.

\begin{lstlisting}
    var DocumentApi = require('./api/docs.js');
    module.exports = exports = function(app, db) {
        sa = new SocketAdapter(app);
        api = new DocumentApi(db, sa);
        app.get('/api/docs', api.docs);
        app.get('/api/docs/:id', api.doc);
        app.post('/api/docs', api.adddoc);
        app.put('/api/docs/:id', api.updatedoc);
        app.delete('/api/docs/:id', api.deletedoc);
    ...
    }

\end{lstlisting}

\begin{lstlisting}
module.exports = function (db, sa) {
  var docs = db.collection("docs");

  this.deletedoc = function(req, res) {
    var oid = mongo.BSONPure.ObjectID(req.params.id)
    docs.remove({_id: oid}, function(err, removed){
      res.json(removed);
    })  
  ...

\end{lstlisting}

Amikor id-ra hivatkozunk mindig szükséges egy \lstinline{BSONPure.ObjectID} példányba csomagolni az azonosítót, mert csak úgy lehet felhasználni MongoDB lekérdezésben.

%----------------------------------------------------------------------------
\subsection{Kétirányú kommunikáció}
%----------------------------------------------------------------------------

Ha azt nézzük, hogy egyidejűleg x darab diagramot szerkeszt diagramonként y darab különböző felhasználó, akkor felmerül az a próbléma, hogy hogyan követjük nyomon, hogy milyen eseményeket milyen socket-ekre kell továbbítani, más szóval hogyan történjen a broadcast. Szerencsére a Socket.IO könyvtár ezt megoldja úgynevezett szoba funkcionalitással, egy szobához hozzáadott socketek tudnak broadcast üzenetet küldeni a többi szobabeli socketnek, ráadásul a socketek eltávolítása is átlátszóan történik és nem kell memóriakezelési próblémákkal küzdeni.Így a socket kezelő szerver oldali logika meglehetősen vékony lesz, de ez is a célja a Socket.IO könyvtárnak. 

Mivel minden szerkesztendő diagramhoz tartozik egy szoba, kézenfekvő a diagram azonosítóját beállítani a szoba neveként. A modularitást szem előtt tartva, a socket kezeléssel kapcsolatos funkcionalitást egy SocketAdapter nevű objektumba csomagoltam. A SocketAdapter példány példányosítja a Socket.IO szervert és gondoskodik az új kapcsolatok beállításáról, rajta keresztül lehet hívni Socket.IO függvényeket.

Egy új socket-re eseménykezelőket hoz létre a SocketAdapter és a legfontosabb talán a \lstinline{room:change} esemény, ami egy diagram megnyitásakor, vagy másik diagram-ra való áttéréskor hívódik meg a kliens által. Ekkor a régi szobából átkerül az új szobába a socket. 

\begin{figure}[!ht]
\centering
\includegraphics[width=15cm,keepaspectratio]{figures/collaboration-seq.png}
\caption{Entitás módosítás feldolgozása}
\label{fig:angularhtml}
\end{figure}




%----------------------------------------------------------------------------
\section{A kliens oldali alkalmazás}
%----------------------------------------------------------------------------



Az AngularJS alkalmazásomnak a fő építőelemei a szolgáltatások, direktívák és kontrollerek. A kontrollerek a DOM egy részéért felelnek összekapcsolva a modellt és a view-t; a direktívák a HTML kiterjesztését valósítják meg új elemekkel, amik újrafelhasználható UI komponenseket hoznak létre; a szolgáltatások ugyancsak újrafelhasználható függőségek, amiket tetszőleges más komponensbe lehet injektálni.

A külső függőségei: 
\begin{enumerate}
\item az AngularJS könyvtár, 
\item az underscoreJS könyvtár ami funkcionális programozási elemekkel bővíti a nyelvet,
\item egy md5 hash-t számoló függvény,
\item Jquery UI a DOM elemek mozgatása miatt,
\item PlumbJS ami DOM elemeket köt össze nyilakkal.
\end{enumerate}

Az első próbálkozásaimban nyilakat a HTML SVG path segítségével próbáltam megvalósítani úgy, hogy adatkötés segítségével frissült a nyíl pozíciója egy elhúzott DOM elemhez képest. Sok funkcionalitást kellett volna implementálnom, így kerestem alternatívákat. A PlumbJS egy élhúzó modul aminek segítségével DOM elemeket meg lehet jelölni mint él kiindulópont vagy végpont és ezt a kettőt összeköti egy SVG alapú vektoros nyíllal. Gondoskodik az új él behúzásáért, nyilvántartja a létrehozott éleket, DOM elem körül egy kerületet kell defineálni és ahhoz kapcsolja az élek végpontjait. Továbbá tud nyilat húzni és cimkét tenni a vonalra; azt a következtetést vontam le, hogy mindent tud, amire szükségem van.  

\subsubsection{Jade markup}

A Jade egy olyan markup nyelv ami HTML-t helyettesít, az a fő különbség, hogy a fa nem XML alapú, hanem a gyerekek indentációval különülnek el a szülőtől, ez amúgy is általánosságban szokás, viszont így nincs rá szükség, hogy be is zárjunk HTML elemeket. Az eredmény karakterszámon spórol és olvashatóbb markupot eredményez. A Jade template a Node alkalmazásban fordul le HTML tartalommá. A Jade valóban template rendszer is, tartalmaz példáúl elégazásokat, de én csak markupként használtam, a logika az az Angular kontrollerekre van bízva.

Template öröklés úgy működik, hogy az \lstinline{extends} paranccsal megjelöljük, hogy ki melyik template a szülő template. A szülőben \lstinline{block} elemeket hozhatunk létre és az ezekben levő DOM rész felülírható a gyerek template-ben. 

Egy hasznos funkció benne a kikommentezés, ami úgy használandó mint a Javascript egy soros komment, viszont a szülő kikommentezése a gyerekek kikommentezését is maga után vonja, így se két helyen nem kell kommentezési parancsot tenni a markupba (a HTML esetében nyitó és záró komment tag kellett) se kiválasztani nem kell a kommentezendő DOM részt.

\begin{lstlisting}
table
  tr
    td(style='width: '+(100/2)+'%').
      Twitter
    td Facebook
\caption{Példa Jade markup}
\end{lstlisting}

\begin{lstlisting}
<table>
  <tr>
    <td style="width: 50%">Twitter</td>
    <td>Facebook</td>
  </tr>
</table>
\caption{Az ekvivalens HTML}
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{Direktívák}
%----------------------------------------------------------------------------

\subsubsection{ntDraggable}

Az ntDraggable direktíva a mozgatható diagram dobozokat valósítja és a 

\begin{lstlisting}
<div ng-repeat="entity in shared_document.entities" nt-draggable="nt-draggable" class="drag"></div>
\end{lstlisting}


kód szúrja be őket a DOM-ba. Az adatkötésnek köszönhetően, ha az entities tömb bővül, vagy ritkul, vagy egy eleme megváltozik, akkor ez a DOM-ban is érvényesül. Ez a direktíva egy HTML template-t is meghatároz a mozgatható entitásnak, gyakorlatilag olyan mintha az eredeti DOM-ban lenne ez a HTML, de, ha új helyre szeretnénk másolni a funkcionalitást nem kell lemásolni. A template a következőket tartalmazza:

\pdfcomment[icon=Note]{insert: Kep a direktivarol}

\pdfcomment[icon=Note]{insert: Kep a függőségi gráfról}

\begin{enumerate}
\item Egy gyerek div ami a \lstinline|{{entity.title}}| kötésen keresztül a doboz nevét írja ki,
\item A model megváltozása esetében a pozíciót is tudom frissíteni CSS attribútumra való kötéssel: \lstinline| style='top:{{entity.position.top}}px;left:{{entity.position.left}}px'|
\item Egy entitás kiválasztása esetében egy CSS osztályt kell hozzáadni a szülőhöz, jelezva , hogy ki van választva. Az AngularJS szolgáltat erre egy \lstinline{ng-class} direktívát ami feltételes CSS class beállítást valósít meg. 
\item \lstinline|id={{entity._id}}| Az entitás adabázis azonosítója egy az egyben a DOM id lesz -- egy nagyon kézenfekvő megoldás.
\item A többi felhasználó kijelölését egy kis doboz jelöli, ami a felhasználóhoz rendelt színnel lesz kiszínezve.
\end{enumerate}

Az ntDraggable direktíva egy \lstinline{link} függvényt is meghatároz, ennek a törzse pont az a hely ahova a DOM manipuláció és eseménykezelő logikát akarjuk tenni -- pontosabban itt az egérrel való tologatást állítom be. Itt látszik, hogy ez a DOM manipuláció függetlenítve van a prezentációs rétegtől és az alkalmazás többi részétől, ami tesztelhetőség és újrafelhasználás szempontjából értelmes. 

Ahhoz, hogy a div mozgatása a jsPlumb élek mozgatását vonja maga után nem \lstinline{jQuery.draggable}-t kell használni, hanem \lstinline{jsPlumb.draggable}-t, ami kiterjeszti az előbbit. A DOM irányából a kötés a modelhez csak a \lstinline{stop} draggable eseményre történik, mert nem akarunk minden egérmozgatásról értesíteni a többi felhasználót, az nem csak hogy pazarló lenne, hanem zavaró is, így csak akkor terjed a módosítás , ha új helyre engedjük el a dobozt.

Az élhúzás egyszerűség kedvéért ugyancsak egér kattintás és húzogatással történik, de nem a dobozt húzzuk, hanem a nevét, ekkor a jsPlumb gondoskodik az új ideiglenes lógó él kirajzolásáról. Ehhez jsPlumb \lstinline{makeSource} és \lstinline{makeTarget} parancsokat kell hívni, ezek beállítják a cím dobozokat mint cél és forrás a jsPlumb élekhez.

Megjegyzendő, hogy direktívák használata miatt a kontroller és a DOM template nincs csatolva a jsPlumb modulhoz, tehát, ha lecserélnénk a jsPlumb megoldást egy sajátra, ez remélhetőleg csak a direktíva módosítását vonja maga után.

\subsubsection{saveSelected}

A szerkesztő kontrollere nyilvántartja a kiválasztott entitást a gráfban, egy korábbi verzióban kettőt is lehetett kiválasztani, majd ezeket össze lehetett gombnyomással kapcsolni éllel, de ez helyettesítve lett a fennebb említett felhasználói szempontból egyszerűbb megoldással. 

Kijelöléskor  
\pdfcomment[icon=Note]{insert: Kep az attributes pane-rol}
az entitás attribútumai megjelennek a részlet nézeten és itt lehet módosítani példáúl a címét. Az adatkötés elintézi, hogy az input doboz tartalma megegyezzen mindkét irányba a modellel, de ettől még nem fognak propagálódni a módosítások a szerverre. 

Ez a direktíva azt csinálja meg, hogy amilyen input elemhez csatoljuk, annak a fókusz elvesztése a kijelölt elem szerverre való mentését váltja ki. A \lstinline{saveSelectedCon} direktíva hasonlóan élek szerverre mentését váltja ki.


\subsubsection{ntDelete}

Az ndDelete direktíva a billentyű funkciókért felelős, amiből kettő van: entitás létrehozás (E gomb) és törlés (backspace gomb). A triviális megoldás az, hogy a document elemre egy \lstinline{keydown} eseménykezelőt állítunk be. Ez sajnos nem elég, mert, ha éppen szöveget szerkesztünk az oldalon, akkor arra is reagálni fog. A direktíva eseménykezelője megkülönbözteti, hogy az eseményt fogadó elem input vagy textarea elem-e és ha igen, akkor az alapértelmezett működés következik be, egyébként meg a backspace hatására az éppen kijelölt entitást vagy élt kitörli.

Fontos megjegyezni, hogy az olyan callback, ami nem AngularJS része, példáúl egy jQuery eseménykezelő, nem fogja az adatkötés frissítését kiváltani, tehát ha backspace gombnál kitörlünk egy entitást a model lsitából, ez a DOM-ban nem fog érvényesülni, ilyenkor \lstinline{$scope.$apply();} parancsot kell hívni. 

%----------------------------------------------------------------------------
\subsection{Szolgáltatások}
%----------------------------------------------------------------------------

\subsubsection{SocketService}

A websocket kezelés egy tökéletes példa saját AngularJS szolgáltatásra, ezt akár több kontroller, direktíva vagy szolgáltatásba szeretnénk injektálni és fontos lenne a könnyű hozzáférés és a scope frissítés \lstinline{$scope.$apply();} segítségével. Pontosan ez történik, a SocketService kapcsolódik a szerveroldali Socket.IO szerverhez, majd apply blokkban futtatja a socket üzenet küldés (emit) és fogadás (on) callback metódusokat.

Így kontrollerből átlátszóan használom ezt az adapter és ez a következőképpen néz ki kontrolleren belül:

\begin{lstlisting}
 function EditorCtrl($scope,socket, ...) {
    socket.on('entity:create', function (data) {
      var entities = $scope.shared_document.entities;
      entities.push(data.obj);
    });
 }
\end{lstlisting}

\subsubsection{API szolgáltatások}

AngularJS az alacsonyszintű $http szolgáltatást kínálja egyszerű AJAX hívásokra, de, ha egy API-val dolgozunk, akkor a $resource egy olyan absztraktabb szolgáltatás ami REST-szerű API-khoz való kapcsolódást valósít meg. Ekkor saját szolgáltatást kell defineálni egy endpoint megadásával és a műveletek meghatározásával:






\begin{lstlisting}
  app.factory('DocumentService', ['$resource', function($resource){
  return $resource('/api/docs/:id', {id:'@_id'}, 
    { update: {method:'PUT' } , 
      query: {method:'GET', isArray: true}});
    }]);
\end{lstlisting}




Látható, hogy a saját DocumentService API-nek a \$resource a függősége, az \lstinline{/api/docs/:id} URL-hez kapcsolódik és kibővítettem két metódussal ami az update és a query metódus. 





Új entitás létrehozásakor kevés kódot kell futtatni:
\begin{lstlisting}
 $scope.addEntity = function() {
    EntityService.save({ 
      position: {"left":300, top:300 },
      title:"*", 
      document: $scope.shared_document._id}, 
      function(res){}
    )
  }
\end{lstlisting}

Az a kényelmes mellékhatása van ennek a kódnak, hogy új entitás létrehozásakor a DOM-ba kerül.\pdfcomment[icon=Note]{insert: Egybol belekerul a domba?}

\subsubsection{JSPlumbService}


A laza csatolás szem előtt tartása miatt a jsPlumb hívások is egy szolgáltatásban vannak és nincsenek a kontroller vagy view-hoz szorosan csatolva. 

Ez a szolgáltatás beállítja az alapértelmezett jsPlumb paramétereket:

\begin{enumerate}
\item az élek görbülésének mértéke és stílusa,
\item az élek színe, vastagsága,
\item a végpontok stílusa,
\item egy overlay beállítása, ami nyilat valósít meg,
\item  rögzítési pont -- ez esetben folytonos -- ami azt jelenti, hogy nem diszkrét számú pontra illeszkedhet, hanem a doboz kerülete mentén egy közelebbi ponthoz fog kapcsolódni a másik doboz helyzetéhez képest.
\end{enumerate}

Két metódust szolgáltat : új élek létrehozása és egy új diagram betöltésekor  vagy váltáskor az élek felrajzolása egy éllista alapján.
Nincsen adatkötés az élek és az AngularJS modellek között, ezért itt kell ezt megvalósítani.

\subsection{Függőségek vizualizálása}

\begin{figure}[!ht]
\centering
\includegraphics[width=15cm,keepaspectratio]{figures/dependencies.png}
\caption{Függőségek vizualizálása AngularJS chrome toolbar-ban}
\label{fig:angulardependencies}
\end{figure}


\cite{https://github.com/angular/angularjs-batarang/blob/master/README.md}
A Batarang nevű kiegészítés a Google Chrome böngészőhöz egy AngularJS debuggoló eszköz, a ~\ref{fig:angulardependencies} ábrán látszik a függőségek vizualizálása, ami az egyik eszköz a Batarang-ban. A kör mentén fel vannak sorakoztatva a beépített -- általában \$-vel kezdődő nevűek -- és a fejlesztő által implementált komponensek: szolgáltatások, direktívák, filterek. A függőségi gráfban egy komponenst kiválasztva zöld színű élek mutatnak az őt felhasználó komponensekre, a pirosak meg azokra mutat amik őt használják.




\subsection{A szerkesztő kontroller}
\label{subsec:hashref}
\begin{enumerate}
\item A kontroller betöltésekor lekéri a DocumentService-től az összes diagramot és majd az elsőt betölti,
\item defineál egy inicializáló metódust ami a diagram betöltését valósítja meg. Ekkor bizonyos változók újra az eredeti értéküket kapják meg, majd frissülnek az API-ból a diagram adatai, az entitásokat lekéri és inicializálja az éleket. A végén socket üzenetet küld arról, hogy az új diagramra váltott és a szerveroldlon egy másik socket szobába kerül;
\item új diagram létreho
\item 
\item 
\end{enumerate}


documenthash

%----------------------------------------------------------------------------
\subsection{Unit teszt esetek}
%----------------------------------------------------------------------------


\input{src/mark}


\input{src/compile}


%----------------------------------------------------------------------------
\section{Az alkalmazás bemutatása}
%----------------------------------------------------------------------------


%----------------------------------------------------------------------------
\section{Továbbfejlesztési lehetőségek}
%----------------------------------------------------------------------------
Derp.


